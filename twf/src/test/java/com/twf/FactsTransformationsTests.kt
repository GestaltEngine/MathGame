import com.twf.config.CheckedFactColor
import com.twf.config.CompiledConfiguration
import com.twf.config.VariableConfiguration
import com.twf.expressiontree.ExpressionSubstitution
import com.twf.factstransformations.TransformationChainParser
import com.twf.factstransformations.checkTransformationChain
import com.twf.factstransformations.parseFromFactIdentifier
import com.twf.org.junit.Assert
import com.twf.org.junit.Ignore
import com.twf.org.junit.Test
import com.twf.substitutiontests.parseStringExpression
import com.twf.visualization.brushMathMl
import com.twf.visualization.dropPerformedBrushing
import kotlin.test.assertEquals

class FactsTransformationsTests {
    val compiledConfiguration = CompiledConfiguration()
    val factComporator = compiledConfiguration.factComporator

    @Test
    fun correctFactAdditiveChain (){
        val transformationChainParser = TransformationChainParser("<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo>=</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>=</mo><mo>&gt;</mo><mo>(</mo><mi mathvariant=\"normal\">x</mi><mo>+</mo><mi mathvariant=\"normal\">y</mi><mo>+</mo><mi mathvariant=\"normal\">z</mi><mo>)</mo><mo>-</mo><mi mathvariant=\"normal\">z</mi><mo>=</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi><mo>=</mo><mo>&gt;</mo><mi mathvariant=\"normal\">x</mi><mo>+</mo><mi mathvariant=\"normal\">y</mi><mo>=</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi></math>",
                compiledImmediateVariableReplacements = mapOf<String, String>(*(VariableConfiguration().variableImmediateReplacementRules.map { Pair(it.left, it.right) }.toTypedArray())))
        val error = transformationChainParser.parse()
        Assert.assertEquals(null, error)
        Assert.assertEquals("AND_NODE(facts chains:(((+(x;y;z));=;(3.1415926535897932384626433832795));((+(+(x;y;z);-(z)));=;(+(3.1415926535897932384626433832795;-(z))));((+(x;y));=;(+(3.1415926535897932384626433832795;-(z))))))", transformationChainParser.root.toString())

        val checkingResult = transformationChainParser.root.check(factComporator, false,
                compiledConfiguration.compiledFactTreeTransformationRules,
                compiledConfiguration.compiledExpressionTreeTransformationRules,
                listOf(parseFromFactIdentifier("x+y+z;ec;=;ec;&#x3C0;")!!))

        val brushedMathML = brushMathMl(transformationChainParser.transformationChain, checkingResult.coloringTasks)

        assertEquals(true, checkingResult.isCorrect)
        assertEquals("<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mrow mathvariant=\"bold\" mathcolor=\"#007F00\"><mo>=</mo></mrow><mi mathvariant=\"normal\">&#x3C0;</mi><mrow mathvariant=\"bold\" mathcolor=\"#007F00\"><mo>=</mo><mo>&gt;</mo></mrow><mo>(</mo><mi mathvariant=\"normal\">x</mi><mo>+</mo><mi mathvariant=\"normal\">y</mi><mo>+</mo><mi mathvariant=\"normal\">z</mi><mo>)</mo><mo>-</mo><mi mathvariant=\"normal\">z</mi><mo>=</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi><mrow mathvariant=\"bold\" mathcolor=\"#007F00\"><mo>=</mo><mo>&gt;</mo></mrow><mi mathvariant=\"normal\">x</mi><mo>+</mo><mi mathvariant=\"normal\">y</mi><mo>=</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi></math>",
                brushedMathML)
    }

    @Test
    fun correctFactAdditiveChainMoreSigns (){
        val transformationChainParser = TransformationChainParser(dropPerformedBrushing("<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo>&gt;</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo mathcolor=\"#007F00\">=</mo><mo mathcolor=\"#007F00\">&gt;</mo><mo>(</mo><mi mathvariant=\"normal\">x</mi><mo>+</mo><mi mathvariant=\"normal\">y</mi><mo>+</mo><mi mathvariant=\"normal\">z</mi><mo>)</mo><mo>-</mo><mi mathvariant=\"normal\">z</mi><mo>&gt;</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi><mo mathcolor=\"#007F00\">=</mo><mo mathcolor=\"#007F00\">&gt;</mo><mi mathvariant=\"normal\">x</mi><mo>+</mo><mi mathvariant=\"normal\">y</mi><mo>&gt;</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi></math>"),
                compiledImmediateVariableReplacements = mapOf<String, String>(*(VariableConfiguration().variableImmediateReplacementRules.map { Pair(it.left, it.right) }.toTypedArray())))
        val error = transformationChainParser.parse()
        Assert.assertEquals(null, error)
        Assert.assertEquals("AND_NODE(facts chains:(((+(x;y;z));>;(3.1415926535897932384626433832795));((+(+(x;y;z);-(z)));>;(+(3.1415926535897932384626433832795;-(z))));((+(x;y));>;(+(3.1415926535897932384626433832795;-(z))))))", transformationChainParser.root.toString())

        val checkingResult = transformationChainParser.root.check(factComporator, false,
                compiledConfiguration.compiledFactTreeTransformationRules,
                compiledConfiguration.compiledExpressionTreeTransformationRules,
                listOf(parseFromFactIdentifier("x+y+z;ec;>;ec;&#x3C0;")!!))

        val brushedMathML = brushMathMl(transformationChainParser.transformationChain, checkingResult.coloringTasks)

        assertEquals(true, checkingResult.isCorrect)
        assertEquals("<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mrow mathvariant=\"bold\" mathcolor=\"#007F00\"><mo>&gt;</mo></mrow><mi mathvariant=\"normal\">&#x3C0;</mi><mrow mathvariant=\"bold\" mathcolor=\"#007F00\"><mo>=</mo><mo>&gt;</mo></mrow><mo>(</mo><mi mathvariant=\"normal\">x</mi><mo>+</mo><mi mathvariant=\"normal\">y</mi><mo>+</mo><mi mathvariant=\"normal\">z</mi><mo>)</mo><mo>-</mo><mi mathvariant=\"normal\">z</mi><mo>&gt;</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi><mrow mathvariant=\"bold\" mathcolor=\"#007F00\"><mo>=</mo><mo>&gt;</mo></mrow><mi mathvariant=\"normal\">x</mi><mo>+</mo><mi mathvariant=\"normal\">y</mi><mo>&gt;</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi></math>",
                brushedMathML)
    }

    @Test
    fun correctFactAdditiveChainLessSignsWrong (){
        val transformationChainParser = TransformationChainParser(dropPerformedBrushing("<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi mathvariant=\"normal\">x</mi><mo>+</mo><mi mathvariant=\"normal\">y</mi><mo>+</mo><mi mathvariant=\"normal\">z</mi><mo>&lt;</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo mathcolor=\"#007F00\">=</mo><mo mathcolor=\"#007F00\">&gt;</mo><mo>(</mo><mi mathvariant=\"normal\">x</mi><mo>+</mo><mi mathvariant=\"normal\">y</mi><mo>+</mo><mi mathvariant=\"normal\">z</mi><mo>)</mo><mo>-</mo><mi mathvariant=\"normal\">z</mi><mo>&lt;</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi><mo mathcolor=\"#007F00\">=</mo><mo mathcolor=\"#007F00\">&gt;</mo><mi mathvariant=\"normal\">x</mi><mo>+</mo><mi mathvariant=\"normal\">y</mi><mo>&lt;</mo><mi mathvariant=\"normal\">&#x3C0;</mi></math>"),
                compiledImmediateVariableReplacements = mapOf<String, String>(*(VariableConfiguration().variableImmediateReplacementRules.map { Pair(it.left, it.right) }.toTypedArray())))
        val error = transformationChainParser.parse()
        Assert.assertEquals(null, error)
        Assert.assertEquals("AND_NODE(facts chains:(((+(x;y;z));<;(3.1415926535897932384626433832795));((+(+(x;y;z);-(z)));<;(+(3.1415926535897932384626433832795;-(z))));((+(x;y));<;(3.1415926535897932384626433832795))))", transformationChainParser.root.toString())

        val checkingResult = transformationChainParser.root.check(factComporator, false,
                compiledConfiguration.compiledFactTreeTransformationRules,
                compiledConfiguration.compiledExpressionTreeTransformationRules,
                listOf())

        assertEquals(false, checkingResult.isCorrect)
        val brushedMathML = brushMathMl(transformationChainParser.transformationChain, checkingResult.coloringTasks)
        assertEquals("<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi mathvariant=\"normal\">x</mi><mo>+</mo><mi mathvariant=\"normal\">y</mi><mo>+</mo><mi mathvariant=\"normal\">z</mi><mrow mathvariant=\"bold\" mathcolor=\"#FF0000\"><mo>&lt;</mo></mrow><mi mathvariant=\"normal\">&#x3C0;</mi><mo>=</mo><mo>&gt;</mo><mo>(</mo><mi mathvariant=\"normal\">x</mi><mo>+</mo><mi mathvariant=\"normal\">y</mi><mo>+</mo><mi mathvariant=\"normal\">z</mi><mo>)</mo><mo>-</mo><mi mathvariant=\"normal\">z</mi><mo>&lt;</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi><mo>=</mo><mo>&gt;</mo><mi mathvariant=\"normal\">x</mi><mo>+</mo><mi mathvariant=\"normal\">y</mi><mo>&lt;</mo><mi mathvariant=\"normal\">&#x3C0;</mi></math>",
                brushedMathML)
    }

    @Test
    fun testCombinatoricCorrectChain (){
        val transformationChainParser = TransformationChainParser("<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>C</mi><mo>(</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo>)</mo><mo>&#xA0;</mo><mo>=</mo><mo>&#xA0;</mo><mi>m</mi><mo>!</mo><mo>&#xA0;</mo><mo>/</mo><mo>&#xA0;</mo><mo>(</mo><mi>m</mi><mo>-</mo><mi>n</mi><mo>)</mo><mo>!</mo><mo>&#xA0;</mo><mo>/</mo><mo>&#xA0;</mo><mi>n</mi><mo>!</mo><mo>&#xA0;</mo><mo>=</mo><mo>&#xA0;</mo><mi>A</mi><mo>(</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo>)</mo><mo>&#xA0;</mo><mo>/</mo><mo>&#xA0;</mo><mi>n</mi><mo>!</mo><mo>&#xA0;</mo><mo>=</mo><mo>&#xA0;</mo><mi>A</mi><mo>(</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo>)</mo><mo>&#xA0;</mo><mo>/</mo><mo>&#xA0;</mo><mi>P</mi><mo>(</mo><mi>n</mi><mo>)</mo></math>")
        val error = transformationChainParser.parse()
        Assert.assertEquals(null, error)
        Assert.assertEquals("AND_NODE(transformation chains:((C(m;n))=(/(factorial(m);factorial(+(m;-(n)));factorial(n)))=(/(A(m;n);factorial(n)))=(/(A(m;n);P(n))));)",
                transformationChainParser.root.toString())

        val checkingResult = transformationChainParser.root.check(factComporator, false,
                compiledConfiguration.compiledFactTreeTransformationRules,
                compiledConfiguration.compiledExpressionTreeTransformationRules,
                listOf())

        println()
        println (brushMathMl(transformationChainParser.transformationChain, checkingResult.coloringTasks))

        assertEquals(true, checkingResult.isCorrect)

        assertEquals(3, checkingResult.coloringTasks.size)
        assertEquals(compiledConfiguration.checkedFactAccentuation.checkedFactColor.correctFactColor, checkingResult.coloringTasks.first().color)
        assertEquals(124, checkingResult.coloringTasks.first().startPosition)
        assertEquals(134, checkingResult.coloringTasks.first().endPosition)
        assertEquals(compiledConfiguration.checkedFactAccentuation.checkedFactColor.correctFactColor, checkingResult.coloringTasks[1].color)
        assertEquals(344, checkingResult.coloringTasks[1].startPosition)
        assertEquals(354, checkingResult.coloringTasks[1].endPosition)
        assertEquals(compiledConfiguration.checkedFactAccentuation.checkedFactColor.correctFactColor, checkingResult.coloringTasks[2].color)
        assertEquals(504, checkingResult.coloringTasks[2].startPosition)
        assertEquals(514, checkingResult.coloringTasks[2].endPosition)
    }

    @Test
    fun testCombinatoricUncorrectChain (){
        val transformationChainParser = TransformationChainParser("<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>C</mi><mo>(</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo>)</mo><mo>&#xA0;</mo><mo>=</mo><mo>&#xA0;</mo><mi>m</mi><mo>!</mo><mo>&#xA0;</mo><mo>/</mo><mo>&#xA0;</mo><mo>(</mo><mi>m</mi><mo>-</mo><mi>n</mi><mo>)</mo><mo>!</mo><mo>&#xA0;</mo><mo>/</mo><mo>&#xA0;</mo><mi>n</mi><mo>!</mo><mo>&#xA0;</mo><mo>=</mo><mo>&#xA0;</mo><mi>U</mi><mo>(</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo>)</mo><mo>&#xA0;</mo><mo>/</mo><mo>&#xA0;</mo><mi>n</mi><mo>!</mo><mo>&#xA0;</mo><mo>=</mo><mo>&#xA0;</mo><mi>U</mi><mo>(</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo>)</mo><mo>&#xA0;</mo><mo>/</mo><mo>&#xA0;</mo><mi>P</mi><mo>(</mo><mi>m</mi><mo>)</mo></math>")
        val error = transformationChainParser.parse()
        Assert.assertEquals(null, error)
        Assert.assertEquals("AND_NODE(transformation chains:((C(m;n))=(/(factorial(m);factorial(+(m;-(n)));factorial(n)))=(/(U(m;n);factorial(n)))=(/(U(m;n);P(m))));)",
                transformationChainParser.root.toString())

        val checkingResult = transformationChainParser.root.check(factComporator, false,
                compiledConfiguration.compiledFactTreeTransformationRules,
                compiledConfiguration.compiledExpressionTreeTransformationRules,
                listOf())

        println()
        println (brushMathMl(transformationChainParser.transformationChain, checkingResult.coloringTasks))

        assertEquals(false, checkingResult.isCorrect)

        assertEquals(2, checkingResult.coloringTasks.size)
        assertEquals(compiledConfiguration.checkedFactAccentuation.checkedFactColor.correctFactColor, checkingResult.coloringTasks.first().color)
        assertEquals(124, checkingResult.coloringTasks.first().startPosition)
        assertEquals(134, checkingResult.coloringTasks.first().endPosition)
        assertEquals(compiledConfiguration.checkedFactAccentuation.checkedFactColor.wrongFactColor, checkingResult.coloringTasks[1].color)
        assertEquals(344, checkingResult.coloringTasks[1].startPosition)
        assertEquals(354, checkingResult.coloringTasks[1].endPosition)
    }

    @Test
    fun testMath10comTrigonometricheskieZadachiDifficultTask1CorrectRule (){
        val transformationChainParser = TransformationChainParser("<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo>=</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>=</mo><mo>&gt;</mo><mo>(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo>)</mo><mo>-</mo><mi>z</mi><mo>=</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi><mo>=</mo><mo>&gt;</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>=</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi><mo>=</mo><mo>&gt;</mo><mfrac><mrow><mi mathvariant=\"normal\">x</mi><mo>+</mo><mi mathvariant=\"normal\">y</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mo>&gt;</mo><mspace linebreak=\"newline\"/><mo>=</mo><mo>&gt;</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>=</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>=</mo><mo>&gt;</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mo>-</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mo>=</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mo>-</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mo>=</mo><mo>&gt;</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>=</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></math>",
                compiledImmediateVariableReplacements = mapOf<String, String>(*(VariableConfiguration().variableImmediateReplacementRules.map { Pair(it.left, it.right) }.toTypedArray())))
        val error = transformationChainParser.parse()
        Assert.assertEquals(null, error)
        Assert.assertEquals("AND_NODE(facts chains:(((+(x;y;z));=;(3.1415926535897932384626433832795));((+(+(x;y;z);-(z)));=;(+(3.1415926535897932384626433832795;-(z))));((+(x;y));=;(+(3.1415926535897932384626433832795;-(z))));((/(+(x;y);2));=;(/(+(3.1415926535897932384626433832795;-(z));2)));((+(/(x;2);/(y;2)));=;(+(/(3.1415926535897932384626433832795;2);-(/(z;2)))));((+(+(/(x;2);/(y;2));-(+(/(x;2);/(y;2);-(/(z;2))))));=;(+(+(/(3.1415926535897932384626433832795;2);-(/(z;2)));-(+(/(x;2);/(y;2);-(/(z;2)))))));((/(z;2));=;(+(/(3.1415926535897932384626433832795;2);-(+(/(x;2);/(y;2))))))))",
                transformationChainParser.root.toString())

        val checkingResult = transformationChainParser.root.check(factComporator, false,
                compiledConfiguration.compiledFactTreeTransformationRules,
                compiledConfiguration.compiledExpressionTreeTransformationRules,
                listOf(parseFromFactIdentifier("x+y+z;ec;=;ec;&#x3C0;")!!))

        val brushedMathML = brushMathMl(transformationChainParser.transformationChain, checkingResult.coloringTasks)

        assertEquals(true, checkingResult.isCorrect)
        assertEquals("<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mrow mathvariant=\"bold\" mathcolor=\"#007F00\"><mo>=</mo></mrow><mi mathvariant=\"normal\">&#x3C0;</mi><mrow mathvariant=\"bold\" mathcolor=\"#007F00\"><mo>=</mo><mo>&gt;</mo></mrow><mo>(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo>)</mo><mo>-</mo><mi>z</mi><mo>=</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi><mrow mathvariant=\"bold\" mathcolor=\"#007F00\"><mo>=</mo><mo>&gt;</mo></mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>=</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi><mrow mathvariant=\"bold\" mathcolor=\"#007F00\"><mo>=</mo><mo>&gt;</mo></mrow><mfrac><mrow><mi mathvariant=\"normal\">x</mi><mo>+</mo><mi mathvariant=\"normal\">y</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi></mrow><mn>2</mn></mfrac><mrow mathvariant=\"bold\" mathcolor=\"#007F00\"><mo>=</mo><mo>&gt;</mo></mrow><mspace linebreak=\"newline\"/><mo>=</mo><mo>&gt;</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>=</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mrow mathvariant=\"bold\" mathcolor=\"#007F00\"><mo>=</mo><mo>&gt;</mo></mrow><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mo>-</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mo>=</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mo>-</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mrow mathvariant=\"bold\" mathcolor=\"#007F00\"><mo>=</mo><mo>&gt;</mo></mrow><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>=</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></math>",
                brushedMathML)
    }

    @Test
    fun testMath10comTrigonometricheskieZadachiDifficultTask1WrongRule (){
        val transformationChainParser = TransformationChainParser("<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo>=</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>=</mo><mo>&gt;</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>=</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></math>",
                compiledImmediateVariableReplacements = mapOf<String, String>(*(VariableConfiguration().variableImmediateReplacementRules.map { Pair(it.left, it.right) }.toTypedArray())))
        val error = transformationChainParser.parse()
        Assert.assertEquals(null, error)
        Assert.assertEquals("AND_NODE(facts chains:(((+(x;y;z));=;(3.1415926535897932384626433832795));((/(z;2));=;(+(/(3.1415926535897932384626433832795;2);-(+(/(x;2);/(y;2))))))))", transformationChainParser.root.toString())

        val checkingResult = transformationChainParser.root.check(factComporator, false,
                compiledConfiguration.compiledFactTreeTransformationRules,
                compiledConfiguration.compiledExpressionTreeTransformationRules,
                listOf(parseFromFactIdentifier("x+y+z;ec;=;ec;&#x3C0;")!!))

        assertEquals(checkingResult.isCorrect, false)
        val brushedMathML = brushMathMl(transformationChainParser.transformationChain, checkingResult.coloringTasks)

        assertEquals("<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mrow mathvariant=\"bold\" mathcolor=\"#007F00\"><mo>=</mo></mrow><mi mathvariant=\"normal\">&#x3C0;</mi><mrow mathvariant=\"bold\" mathcolor=\"#FF0000\"><mo>=</mo><mo>&gt;</mo></mrow><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>=</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></math>",
                brushedMathML)
    }

    @Test
    fun testMath10comTrigonometricheskieZadachiDifficultTask1FirstRuleUse (){
        val transformationChainParser = TransformationChainParser("<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo>[</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo>=</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>=</mo><mo>&gt;</mo><mo>(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo>)</mo><mo>-</mo><mi>z</mi><mo>=</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi><mo>=</mo><mo>&gt;</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>=</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi><mo>=</mo><mo>&gt;</mo><mfrac><mrow><mi mathvariant=\"normal\">x</mi><mo>+</mo><mi mathvariant=\"normal\">y</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mo>&gt;</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>=</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>]</mo><mspace linebreak=\"newline\"/><mo>[</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>=</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>=</mo><mo>&gt;</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mo>-</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mo>=</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mo>-</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mo>=</mo><mo>&gt;</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>=</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mo>]</mo><mspace linebreak=\"newline\"/><mfrac><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac></math>",
                compiledImmediateVariableReplacements = mapOf<String, String>(*(VariableConfiguration().variableImmediateReplacementRules.map { Pair(it.left, it.right) }.toTypedArray())))
        val error = transformationChainParser.parse()
        Assert.assertEquals(null, error)
        Assert.assertEquals("AND_NODE(rules:([:AND_NODE(facts chains:(((+(x;y;z));=;(3.1415926535897932384626433832795));((+(+(x;y;z);-(z)));=;(+(3.1415926535897932384626433832795;-(z))));((+(x;y));=;(+(3.1415926535897932384626433832795;-(z))));((/(+(x;y);2));=;(/(+(3.1415926535897932384626433832795;-(z));2)));((+(/(x;2);/(y;2)));=;(+(/(3.1415926535897932384626433832795;2);-(/(z;2)))))))];[:AND_NODE(facts chains:(((+(/(x;2);/(y;2)));=;(+(/(3.1415926535897932384626433832795;2);-(/(z;2)))));((+(+(/(x;2);/(y;2));-(+(/(x;2);/(y;2);-(/(z;2))))));=;(+(+(/(3.1415926535897932384626433832795;2);-(/(z;2)));-(+(/(x;2);/(y;2);-(/(z;2)))))));((/(z;2));=;(+(/(3.1415926535897932384626433832795;2);-(+(/(x;2);/(y;2))))))))]);transformation chains:((+(/(sin(+(/(x;2);/(y;2)));*(sin(/(x;2));sin(/(y;2))));/(cos(/(z;2));sin(/(z;2)))))=(+(/(sin(+(/(3.1415926535897932384626433832795;2);-(/(z;2))));*(sin(/(x;2));sin(/(y;2))));/(cos(/(z;2));sin(/(z;2)))))=(+(/(cos(/(z;2));*(sin(/(x;2));sin(/(y;2))));/(cos(/(z;2));sin(/(z;2))))));)",
                transformationChainParser.root.toString())

        val checkingResult = transformationChainParser.root.check(factComporator, false,
                compiledConfiguration.compiledFactTreeTransformationRules,
                compiledConfiguration.compiledExpressionTreeTransformationRules +
                ExpressionSubstitution(parseStringExpression("sin(pi/2-z/2)"),
                        parseStringExpression("cos(z/2)"), basedOnTaskContext = true),
                listOf(parseFromFactIdentifier("x+y+z;ec;=;ec;&#x3C0;")!!))

        println()
        println (brushMathMl(transformationChainParser.transformationChain, checkingResult.coloringTasks))

        assertEquals(true, checkingResult.isCorrect)
    }

    @Test
    fun testMath10comTrigonometricheskieZadachiDifficultTask1CorrectSolution (){
        val transformationChainParser = TransformationChainParser("<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo>[</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo>=</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>=</mo><mo>&gt;</mo><mo>(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo>)</mo><mo>-</mo><mi>z</mi><mo>=</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi><mo>=</mo><mo>&gt;</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>=</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi><mo>=</mo><mo>&gt;</mo><mfrac><mrow><mi mathvariant=\"normal\">x</mi><mo>+</mo><mi mathvariant=\"normal\">y</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi></mrow><mn>2</mn></mfrac><mo>=</mo><mo>&gt;</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>=</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>]</mo><mspace linebreak=\"newline\"/><mo>[</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>=</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>=</mo><mo>&gt;</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mo>-</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mo>=</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mo>-</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mo>=</mo><mo>&gt;</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>=</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mo>]</mo><mspace linebreak=\"newline\"/><mi>ctg</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mi>ctg</mi><mfenced><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac></mfenced><mo>+</mo><mi>ctg</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mo>=</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>=</mo><mspace linebreak=\"newline\"/><mo>=</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>=</mo><mspace linebreak=\"newline\"/><mo>=</mo><mfrac><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>=</mo><mspace linebreak=\"newline\"/><mo>=</mo><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mfenced><mfrac><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac></mfenced><mo>=</mo><mspace linebreak=\"newline\"/><mo>=</mo><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mfenced><mfrac><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mo>)</mo><mo>+</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac></mfenced><mo>=</mo><mspace linebreak=\"newline\"/><mo>=</mo><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mfenced><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac></mfenced><mo>=</mo><mspace linebreak=\"newline\"/><mo>=</mo><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mfenced><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac></mfenced><mo>=</mo><mi>ctg</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>ctg</mi><mfenced><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac></mfenced><mi>ctg</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></math>")
        val error = transformationChainParser.parse()
        Assert.assertEquals(null, error)
        Assert.assertEquals("AND_NODE(rules:([:AND_NODE(facts chains:(((+(x;y;z));=;(&#x3C0));((+(+(x;y;z);-(z)));=;(+(&#x3C0;-(z))));((+(x;y));=;(+(&#x3C0;-(z))));((/(+(x;y);2));=;(/(+(&#x3C0;-(z));2)));((+(/(x;2);/(y;2)));=;(+(/(&#x3C0;2);-(/(z;2)))))))];[:AND_NODE(facts chains:(((+(/(x;2);/(y;2)));=;(+(/(&#x3C0;2);-(/(z;2)))));((+(+(/(x;2);/(y;2));-(+(/(x;2);/(y;2);-(/(z;2))))));=;(+(+(/(&#x3C0;2);-(/(z;2)));-(+(/(x;2);/(y;2);-(/(z;2)))))));((/(z;2));=;(+(/(&#x3C0;2);-(+(/(x;2);/(y;2))))))))]);transformation chains:((+(ctg(/(x;2));ctg(/(y;2));ctg(/(z;2))))=(+(/(cos(/(x;2));sin(/(x;2)));/(cos(/(y;2));sin(/(y;2)));/(cos(/(z;2));sin(/(z;2)))))=(+(/(+(*(cos(/(x;2));sin(/(y;2)));*(cos(/(y;2));sin(/(x;2))));*(sin(/(x;2));sin(/(y;2))));/(cos(/(z;2));sin(/(z;2)))))=(+(/(sin(+(/(x;2);/(y;2)));*(sin(/(x;2));sin(/(y;2))));/(cos(/(z;2));sin(/(z;2)))))=(+(/(sin(+(/(&#x3C0;2);-(/(z;2))));*(sin(/(x;2));sin(/(y;2))));/(cos(/(z;2));sin(/(z;2)))))=(+(/(cos(/(z;2));*(sin(/(x;2));sin(/(y;2))));/(cos(/(z;2));sin(/(z;2)))))=(*(cos(/(z;2));/(+(sin(/(z;2));*(sin(/(x;2));sin(/(y;2))));*(sin(/(x;2));sin(/(y;2));sin(/(z;2))))))=(*(cos(/(z;2));/(+(sin(+(/(&#x3C0;2);-(+(/(x;2);/(y;2)))));*(sin(/(x;2));sin(/(y;2))));*(sin(/(x;2));sin(/(y;2));sin(/(z;2))))))=(*(cos(/(z;2));/(+(cos(+(/(x;2);/(y;2)));*(sin(/(x;2));sin(/(y;2))));*(sin(/(x;2));sin(/(y;2));sin(/(z;2))))))=(*(cos(/(z;2));/(*(cos(/(x;2));cos(/(y;2)));*(sin(/(x;2));sin(/(y;2));sin(/(z;2))))))=(*(ctg(/(x;2));ctg(/(y;2));ctg(/(z;2)))));)",
                transformationChainParser.root.toString())

        val checkingResult = transformationChainParser.root.checkTransformationChain(
                factComporator, false,
                listOf(parseFromFactIdentifier("x+y+z;ec;=;ec;pi")!!))

        println()
        println (brushMathMl(transformationChainParser.transformationChain, checkingResult.coloringTasks))

        assertEquals(true, checkingResult.isCorrect)
    }

    @Test
    fun testMath10comTrigonometricheskieZadachiDifficultTask1WrongCondition (){
        val transformationChainParser = TransformationChainParser("<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo>[</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo>=</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>=</mo><mo>&gt;</mo><mi mathvariant=\"normal\">x</mi><mo>+</mo><mi mathvariant=\"normal\">y</mi><mo>=</mo><mi mathvariant=\"normal\">&#x3C0;</mi><mo>-</mo><mi mathvariant=\"normal\">z</mi><mo>=</mo><mo>&gt;</mo><mspace linebreak=\"newline\"/><mo>=</mo><mo>&gt;</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>=</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>=</mo><mo>&gt;</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>=</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mo>]</mo><mspace linebreak=\"newline\"/><mi>ctg</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mi>ctg</mi><mfenced><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac></mfenced><mo>+</mo><mi>ctg</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mo>=</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>=</mo><mspace linebreak=\"newline\"/><mo>=</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>=</mo><mspace linebreak=\"newline\"/><mo>=</mo><mfrac><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac><mo>=</mo><mspace linebreak=\"newline\"/><mo>=</mo><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mfenced><mfrac><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac></mfenced><mo>=</mo><mspace linebreak=\"newline\"/><mo>=</mo><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mfenced><mfrac><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">&#x3C0;</mi><mn>2</mn></mfrac><mo>-</mo><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mo>)</mo><mo>+</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac></mfenced><mo>=</mo><mspace linebreak=\"newline\"/><mo>=</mo><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mfenced><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac></mfenced><mo>=</mo><mspace linebreak=\"newline\"/><mo>=</mo><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo><mfenced><mfrac><mrow><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>cos</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac><mo>)</mo><mi>sin</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></mrow></mfrac></mfenced><mo>=</mo><mi>ctg</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">x</mi><mn>2</mn></mfrac><mo>)</mo><mi>ctg</mi><mfenced><mfrac><mi mathvariant=\"normal\">y</mi><mn>2</mn></mfrac></mfenced><mi>ctg</mi><mo>(</mo><mfrac><mi mathvariant=\"normal\">z</mi><mn>2</mn></mfrac><mo>)</mo></math>")
        val error = transformationChainParser.parse()
        Assert.assertEquals(null, error)
        Assert.assertEquals("AND_NODE(rules:([:AND_NODE(facts chains:(((+(x;y;z));=;(&#x3C0));((+(x;y));=;(+(&#x3C0;-(z))));((+(/(x;2);/(y;2)));=;(+(/(&#x3C0;2);-(/(z;2)))));((/(z;2));=;(+(/(&#x3C0;2);-(+(/(x;2);/(y;2))))))))]);transformation chains:((+(ctg(/(x;2));ctg(/(y;2));ctg(/(z;2))))=(+(/(cos(/(x;2));sin(/(x;2)));/(cos(/(y;2));sin(/(y;2)));/(cos(/(z;2));sin(/(z;2)))))=(+(/(+(*(cos(/(x;2));sin(/(y;2)));*(cos(/(y;2));sin(/(x;2))));*(sin(/(x;2));sin(/(y;2))));/(cos(/(z;2));sin(/(z;2)))))=(+(/(sin(+(/(x;2);/(y;2)));*(sin(/(x;2));sin(/(y;2))));/(cos(/(z;2));sin(/(z;2)))))=(+(/(sin(+(/(&#x3C0;2);-(/(z;2))));*(sin(/(x;2));sin(/(y;2))));/(cos(/(z;2));sin(/(z;2)))))=(+(/(cos(/(z;2));*(sin(/(x;2));sin(/(y;2))));/(cos(/(z;2));sin(/(z;2)))))=(*(cos(/(z;2));/(+(sin(/(z;2));*(sin(/(x;2));sin(/(y;2))));*(sin(/(x;2));sin(/(y;2));sin(/(z;2))))))=(*(cos(/(z;2));/(+(sin(+(/(&#x3C0;2);-(+(/(x;2);/(y;2)))));*(sin(/(x;2));sin(/(y;2))));*(sin(/(x;2));sin(/(y;2));sin(/(z;2))))))=(*(cos(/(z;2));/(+(cos(+(/(x;2);/(y;2)));*(sin(/(x;2));sin(/(y;2))));*(sin(/(x;2));sin(/(y;2));sin(/(z;2))))))=(*(cos(/(z;2));/(*(cos(/(x;2));cos(/(y;2)));*(sin(/(x;2));sin(/(y;2));sin(/(z;2))))))=(*(ctg(/(x;2));ctg(/(y;2));ctg(/(z;2)))));)", transformationChainParser.root.toString())

        val checkingResult = transformationChainParser.root.check(factComporator, false,
                compiledConfiguration.compiledFactTreeTransformationRules,
                compiledConfiguration.compiledExpressionTreeTransformationRules,
                listOf())

        assertEquals(false, checkingResult.isCorrect)
    }

    @Test
    fun testComCorrect (){
        val transformationChainParser = TransformationChainParser("<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>a</mi><mo>=</mo><mi>a</mi><mo>+</mo><mi>b</mi></math>")
        val error = transformationChainParser.parse()
        Assert.assertEquals(null, error)
        Assert.assertEquals("AND_NODE(transformation chains:((+(a;b))=(+(b;a))=(+(a;b)));)", transformationChainParser.root.toString())

        val checkingResult = transformationChainParser.root.check(factComporator, false,
                compiledConfiguration.compiledFactTreeTransformationRules,
                compiledConfiguration.compiledExpressionTreeTransformationRules,
                listOf())

        assertEquals(checkingResult.isCorrect, true)
    }

    @Test
    @Ignore
    fun testEquationCorrect (){  //TODO: fix problem in comparison with original facts just by its identifiers
        val transformationChainParser = TransformationChainParser("<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo>(</mo><mi>y</mi><mo>+</mo><mi>x</mi><mo>)</mo><mo>=</mo><mn>7</mn><mo>=</mo><mo>&gt;</mo><mo>(</mo><mi>y</mi><mo>+</mo><mi>x</mi><mo>)</mo><mo>-</mo><mi>x</mi><mo>=</mo><mn>7</mn><mo>-</mo><mi>x</mi><mspace linebreak=\"newline\"/><mi>y</mi><mo>=</mo><mn>7</mn><mo>-</mo><mi>x</mi></math>")
        val error = transformationChainParser.parse()
        Assert.assertEquals(null, error)
        Assert.assertEquals("AND_NODE(facts chains:(((+(y;x));=;(7));((+(+(y;x);-(x)));=;(+(7;-(x))));((y);=;(+(7;-(x))))))", transformationChainParser.root.toString())

        val checkingResult = transformationChainParser.root.check(factComporator, false,
                compiledConfiguration.compiledFactTreeTransformationRules,
                compiledConfiguration.compiledExpressionTreeTransformationRules,
                listOf(parseFromFactIdentifier("x+y;ec;=;ec;7")!!))
        val brushedMathML = brushMathMl(transformationChainParser.transformationChain, checkingResult.coloringTasks)

        assertEquals("",
                brushedMathML)
        assertEquals(checkingResult.isCorrect, true)
    }
}